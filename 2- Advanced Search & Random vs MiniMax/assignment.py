# -*- coding: utf-8 -*-
"""CS3793_5233_assignment2_llx812.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KixUwYpOJL4uS8piw8yz_BPYQeOKmiwS

```
# This is formatted as code
```

# UTSA CS 3793/5233: Assignment-2

**Last Name - First Name - (abc123)**

## Learning Objectives



*   Game Playing
*   Chess - Board Setup & Rules
*   Adversarial Search
*   AI - Random vs MinMax

## Description

This assignment is focused on **game playing** and creating a proper **AI for chess**.
In the following sections, you will complete a series of tasks to create a chess game board, rules for each chess piece, a Random AI and a MinMax AI that plays a game of chess for both players (white and black).

The base structure of the code is provided. You are supposed to write code for each of the functions. Comments are provided on what should be done. You **CANNOT** use a complete chess library and change the base code structure completely. However, you **CAN** change the code layout and name/format of the functions.

#Chess Board Setup & Rules

In this section, you will write code to import the necessary libraries and create:

1.   **ChessBoard** - This part will contain code to initialize the board, draw the board, get the board state and move piece.
2.   **ChessRules** - This part will contain code for the chess rules for each piece.

##Import Libraries

The code here will contain only **import** statements. A base list of the required libraries are already imported. You will most likely not need any other libraries, but if needed, add the import statements here. As mentioned before, you can not use any premade chess libraries.
"""

# your code goes here
import string
import random
import os
import sys
import time
from IPython.display import clear_output

"""##ChessBoard

(10 points)

Fill the code in the code structure provided below for the ChessBoard. The main use of this code block write functions to initialize the board, draw the board, get the board state and move piece. You can add any other functions if needed.

"""

# you can add/change the input parameters for each function
# you can change the function names and also add more functions if needed


def ChessBoardSetup():
    # initialize and return a chess board - create a 2D 8x8 array that has the value for each cell
    # USE the following characters for the chess pieces - lower-case for BLACK and upper-case for WHITE
    # . for empty board cell
    # p/P for pawn
    # r/R for rook
    # t/T for knight
    # b/B for bishop
    # q/Q for queen
    # k/K for king

    board = [['.' for _ in  range(8) ] for _ in range(8)]


    board[0]=  ["r", "t", "b", "q", "k", "b", "t", "r" ]
    board [1]= ["p", "p", "p", "p", "p", "p", "p", "p" ]
    board[6]=  ["P", "P", "P", "P", "P", "P", "P", "P" ]
    board [7]= ["R", "T", "B", "Q", "K", "B", "T", "R" ]

    return board


def DrawBoard(board):
    # write code to print the board - following is one print example
    # r t b q k b t r
    # p p p p p p p p
    # . . . . . . . .
    # . . . . . . . .
    # . . . . . . . .
    # . . . . . . . .
    # P P P P P P P P
    # R T B Q K B T R
    for row in board:
        print(' '.join(row))

def MovePiece(board, from_square, to_square):
    # write code to move the one chess piece
    # you do not have to worry about the validity of the move - this will be done before calling this function
    # this function will at least take the move (from-piece and to-piece) as input and return the new board layout
    # Find the position of from_piece on the board.



    from_piece = board[from_square[0]][from_square[1]]

    to_piece = board[to_square[0]][to_square[1]]

    from_piece_found = False
    from_row, from_col = -1, -1
    for row_idx, row in enumerate(board):
        for col_idx, piece in enumerate(row):

            if piece == from_piece:
                from_piece_found = True
                from_row, from_col = row_idx, col_idx
                break
        if from_piece_found:
            break

    if not from_piece_found:
        print(f"Piece '{from_piece}' not found on the board.")
        return board

    # Find the position of to_piece on the board.
    to_row, to_col = -1, -1
    for row_idx, row in enumerate(board):
        for col_idx, piece in enumerate(row):
            if piece == to_piece:
                to_row, to_col = row_idx, col_idx
                break
        if to_row != -1 and to_col != -1:
            break

    # Move the piece to the new position.
    board[to_row][to_col] = from_piece
    board[from_row][from_col] = '.'

    return board

board = ChessBoardSetup()
print(DrawBoard(board))
print("\nmove one piece chess:")
from_square = (1, 0)
to_square = (2, 0)

new_board = MovePiece(board, from_square, to_square)
DrawBoard(new_board)

"""##ChessRules

(50 points)

Fill the code in the code structure provided below for ChessRules. The main use of the code block is to write functions to design the rules for movement of each piece on the board. This block will also contain the function to check if the current player is in check, check-mate. You can also have functions that can return the current player's pieces that have legal moves in the current board state.

Following are some **suggested** functions with the pseudocode provided. You can create/remove functions as needed.

"""

# return True if the input move (from-square and to-square) is legal, else False
# this is the KEY function which contains the rules for each piece type
def IsMoveLegal(from_square, to_square, board):
    # input is from-square and to-square
    # use the input and the board to get the from-piece and to-piece
    from_piece = board[from_square[0]][from_square[1]]
    to_piece = board[to_square[0]][to_square[1]]
    #print("from_piece: ", from_piece, "to_piece:", to_piece)

    # if from-square is the same as to-square
        # return False
    if from_square == to_square:
        return False

    # if the from-piece is a "pawn"
        ## case - pawn wants to move one step forward (or backward if white)
        # if to-square is empty and is in the same column as the from-square
            # return True
        ## case - pawn can move two spaces forward (or backward if white) ONLY if pawn on starting row
        # else if to-square is empty and from-square-row = 2 (or 7 if white) and to-square-row = from-square-row + 2 (or -2 if white)
            # if IsClearPath() - a clear path exists between from-square and to-square
                # return True
        ## case - pawn attacks the enemy piece if diagonal
        # else if there is piece diagonally forward (or backward if white) and that piece belongs to the enemy team
            # return True
    # If the from-piece is a "pawn"
    if from_piece == 'p' or from_piece == 'P':
        from_x, from_y = from_square
        to_x, to_y = to_square

        # Case: Pawn wants to move one step forward (or backward if white)
        if to_piece == '.' and to_y == from_y:
            if from_piece == 'p' and to_x == from_x + 1:
                return True
            elif from_piece == 'P' and to_x == from_x - 1:
                return True

        # Case: Pawn can move two spaces forward (or backward if white) ONLY if pawn on starting row
        if from_piece == 'p' and from_x == 1 and to_x == from_x + 2:
            if to_piece == '.' and IsClearPath(from_square, to_square, board):
                return True
        elif from_piece == 'P' and from_x == 6 and to_x == from_x - 2:
            if to_piece == '.' and IsClearPath(from_square, to_square, board):
                return True

        # Case: Pawn attacks the enemy piece if diagonal
        if abs(to_y - from_y) == 1:
            if from_piece == 'p' and to_x == from_x + 1:
                if to_piece.isupper():
                    return True
            elif from_piece == 'P' and to_x == from_x - 1:
                if isinstance(to_piece, str):
                    if to_piece.islower():
                        return True


    # else if the from-piece is a "rook"
        # if to-square is either in the same row or column as the from-square
            # if to-square is either empty or contains a piece that belongs to the enemy team
                # if IsClearPath() - a clear path exists between from-square and to-square
                    # return True
      # If the from-piece is a "rook"
    elif from_piece == 'r' or from_piece == 'R':
        from_row, from_col = from_square
        to_row, to_col = to_square

        # Check if to-square is either in the same row or column as the from-square
        if to_row == from_row or to_col == from_col:
            if isinstance(to_piece, str):
                if to_piece == '.' or (to_piece.islower() and from_piece.isupper()) or (to_piece.isupper() and from_piece.islower()):
                    if IsClearPath(from_square, to_square, board):
                        return True


    # else if the from-piece is a "bishop"
        # if to-square is diagonal wrt from-square
            # if to-square is either empty or contains a piece that belongs to the enemy team
                # if IsClearPath() - a clear path exists between from-square and to-square
                    # return True

    # If the from-piece is a "bishop"
    # If the from-piece is a "bishop"
    elif from_piece == 'b' or from_piece == 'B':
        from_row, from_col = from_square
        to_row, to_col = to_square

        # Check if to-square is diagonal wrt from-square
        if abs(to_row - from_row) == abs(to_col - from_col):
            if isinstance(to_piece, str):
                if to_piece == '.' or (to_piece.islower() and from_piece.isupper()) or (to_piece.isupper() and from_piece.islower()):
                    if IsClearPath(from_square, to_square, board):
                        return True


    # else if the from-piece is a "queen"
        ## SAME as "rook"
        # if to-square is either in the same row or column as the from-square
            # if to-square is either empty or contains a piece that belongs to the enemy team
                # if IsClearPath() - a clear path exists between from-square and to-square
                    # return True
        ## SAME as "bishop"
        # if to-square is diagonal wrt from-square
            # if to-square is either empty or contains a piece that belongs to the enemy team
                # if IsClearPath() - a clear path exists between from-square and to-square
                    # return True
    elif from_piece == 'q' or from_piece == 'Q':
        from_row, from_col = from_square
        to_row, to_col = to_square

        # Check if to-square is either in the same row or column as the from-square
        if to_row == from_row or to_col == from_col:
            if isinstance(to_piece, str):
                if to_piece == '.' or (to_piece.islower() and from_piece.isupper()) or (to_piece.isupper() and from_piece.islower()):
                    if IsClearPath(from_square, to_square, board):
                        return True

        # Check if to-square is diagonal wrt from-square
        if abs(to_row - from_row) == abs(to_col - from_col):
            if isinstance(to_piece, str):
                if to_piece == '.' or (to_piece.islower() and from_piece.isupper()) or (to_piece.isupper() and from_piece.islower()):
                    if IsClearPath(from_square, to_square, board):
                        return True


    # else if the from-piece is a "knight"
        # calculate the col-diff = to-square-col - from-square-col
        # calculate the row-diff = to-square-row - from-square-row
        # if to-square is either empty or contains a piece that belongs to the enemy team
            # return True for any of the following cases:
                # col-diff = 1 & row_dif = -2
                # col-diff = 2 & row_dif = -1
                # col-diff = 2 & row_dif = 1
                # col-diff = 1 & row_dif = 2
                # col-diff = -1 & row_dif = -2
                # col-diff = -2 & row_dif = -1
                # col-diff = -2 & row_dif = 1
                # col-diff = -1 & row_dif = 2
    elif from_piece == 't' or from_piece == 'T':
        col_diff = abs(to_square[1] - from_square[1])
        row_diff = abs(to_square[0] - from_square[0])
        if isinstance(to_piece, str):
            if to_piece == '.' or (to_piece.islower() and from_piece.isupper()) or (to_piece.isupper() and from_piece.islower()):
                if (col_diff == 1 and row_diff ==-2) or (col_diff == 2 and row_diff == -1) or \
                    (col_diff == 2 and row_diff == 1) or (col_diff == 1 and row_diff == 2) or \
                    (col_diff == -1 and row_diff == -2) or (col_diff == -2 and row_diff == -1) or \
                    (col_diff == -2 and row_diff == 1) or (col_diff == -1 and row_diff == 2):
                    return True


    # else if the from-piece is a "king"
        # calculate the col-diff = to-square-col - from-square-col
        # calculate the row-diff = to-square-row - from-square-row
        # if to-square is either empty or contains a piece that belongs to the enemy team
            # return True for any of the following cases:
                # abs(col-diff) = 1 & abs(row_dif) = 0
                # abs(col-diff) = 0 & abs(row_dif) = 1
                # abs(col-diff) = 1 & abs(row_dif) = 1
    # If the from-piece is a "king"
    # If the from-piece is a "king"
    elif from_piece == 'k' or from_piece == 'K':
        col_diff = abs(to_square[1] - from_square[1])
        row_diff = abs(to_square[0] - from_square[0])
        if isinstance(to_piece, str):
            if to_piece == '.' or (to_piece.islower() and from_piece.isupper()) or (to_piece.isupper() and from_piece.islower()):
                if  (col_diff ==1 and row_diff ==0) or \
                    (col_diff ==0 and row_diff ==1) or \
                    (col_diff ==1 and row_diff ==1):
                    return True
    # return False - if none of the other True's are hit above
    else:
        return False

# gets a list of legal moves for a given piece
# input = from-square
# output = list of to-square locations where the piece can move to
def GetListOfLegalMoves(curPlayer, from_square, board):
    # input is the current player and the given piece as the from-square
    # initialize the list of legal moves, i.e., to-square locations to []
    # go through all squares on the board
    # for the selected square as to-square
        # call IsMoveLegal() with input as from-square and to-square and save the returned value
        # if returned value is True
            # call DoesMovePutPlayerInCheck() with input as from-square and to-square and save the returned value
            # if returned value is False
                # append this move (to-square) as a legal move
    # return the list of legal moves, i.e., to-square locations
  legal_moves = []


  for row in range(8):
      for col in range(8):
          to_square = (row, col)
          if IsMoveLegal(from_square, to_square, board):
              if not DoesMovePutPlayerInCheck(curPlayer, from_square, to_square, board):
                  legal_moves.append(to_square)
  return legal_moves


# gets a list of all pieces for the current player that have legal moves
def GetPiecesWithLegalMoves(current_player, board):
    # initialize the list of pieces with legal moves to []
    # go through all squares on the board
    # for the selected square
        # if the square contains a piece that belongs to the current player's team
            # call GetListOfLegalMoves() to get a list of all legal moves for the selected piece / square
            # if there are any legel moves
                # append this piece to the list of pieces with legal moves
    # return the final list of pieces with legal moves

  pieces_with_legal_moves = []
  for row in range(8):
      for col in range(8):
          square = (row, col)
          piece = board[row][col]
          #print("GetPiecesWithLegalMoves")
          #print("piece:", piece)
          if piece is None:
              continue
          if current_player == 'white' and isinstance(piece,str):
              #print("board[row][col].isupper():", board[row][col].isupper())

              if piece.isupper() :
              #if board[row][col].isupper():
                  legal_moves = GetListOfLegalMoves(current_player, (row, col), board)
                  if legal_moves:
                      pieces_with_legal_moves.append(square)
          elif current_player == 'black' and isinstance(piece,str):
              if piece.islower() :
                  legal_moves = GetListOfLegalMoves(current_player, (row, col), board)
                  if legal_moves:
                      pieces_with_legal_moves.append(square)
  return pieces_with_legal_moves


# returns True if the current player is in checkmate, else False
def IsCheckmate(curPlayer, board):
    # call GetPiecesWithLegalMoves() to get all legal moves for the current player
    # if there is no piece with any valid move
        # return True
    # else
        # return False
  pieces_with_legal_moves = GetPiecesWithLegalMoves(curPlayer, board)


    #print("pieces_with_legal_moves from IsCheckmate.\n",pieces_with_legal_moves)
    # If there is no piece with any valid move, return True
  if not pieces_with_legal_moves:
      return True
  else:
      return False


# returns True if the given player is in Check state
def IsInCheck(player, board):
    # find given player's King's location = king-square
    # go through all squares on the board
        # if there is a piece at that location and that piece is of the enemy team
            # call IsMoveLegal() for the enemy player from that square to the king-square
            # if the value returned is True
                # return True
            # else
                # do nothing and continue
    # return False at the end

  # Find the given player's King's location = king-square
    king_square = find_king_square(player, board)

    # Go through all squares on the board
    for row in range(8):
        for col in range(8):
            square = (row, col)
            piece = board[row][col]

            # If there is a piece at that location and that piece is of the enemy team
            if player == 'white' and isinstance(piece, str):
                if piece.isupper() :
                    # Call IsMoveLegal() for the enemy player from that square to the king-square
                    if IsMoveLegal(square, king_square, board):
                        # If the value returned is True, return True
                        return True

            # If there is a piece at that location and that piece is of the enemy team
            if player == 'black' and isinstance(piece, str):
                if piece.islower():
                    # Call IsMoveLegal() for the enemy player from that square to the king-square
                    if IsMoveLegal(square, king_square, board):
                        # If the value returned is True, return True
                        return True
    # Return False at the end
    return False

def find_king_square(player, board):
    # Find the location of the given player's King on the board

    for row in range(8):
        for col in range(8):
            piece = board[row][col]
            if piece == 'K' and player == 'white':
                return (row, col)
            elif piece == 'k' and player == 'black':
                return (row, col)

# helper function to figure out if a move is legal for straight-line moves (rooks, bishops, queens, pawns)
# returns True if the path is clear for a move (from-square and to-square), non-inclusive
def IsClearPath(from_square, to_square, board):
    # given the move (from-square and to-square)

    # if the from and to squares are only one square apart
        # return True
    # else
        # if to-square is in the +ve vertical direction from from-square
            # new-from-square = next square in the +ve vertical direction
        # else if to-square is in the -ve vertical direction from from-square
            # new-from-square = next square in the -ve vertical direction
        # else if to-square is in the +ve horizontal direction from from-square
            # new-from-square = next square in the +ve horizontal direction
        # else if to-square is in the -ve horizontal direction from from-square
            # new-from-square = next square in the -ve horizontal direction
        # else if to-square is in the SE diagonal direction from from-square
            # new-from-square = next square in the SE diagonal direction
        # else if to-square is in the SW diagonal direction from from-square
            # new-from-square = next square in the SW diagonal direction
        # else if to-square is in the NE diagonal direction from from-square
            # new-from-square = next square in the NE diagonal direction
        # else if to-square is in the NW diagonal direction from from-square
            # new-from-square = next square in the NW diagonal direction

    # if new-from-square is not empty
        # return False
    # else
        # return the result from the recursive call of IsClearPath() with the new-from-square and to-square

  if abs(to_square[0] - from_square[0]) <= 1 and abs(to_square[1] - from_square[1]) <= 1:
        return True  # If from-square and to-square are only one square apart, return True

  from_row, from_col = from_square
  to_row, to_col = to_square

  if to_row > from_row:
      new_from_square = (from_row + 1, from_col)
  elif to_row < from_row:
      new_from_square = (from_row - 1, from_col)
  elif to_col > from_col:
      new_from_square = (from_row, from_col + 1)
  elif to_col < from_col:
      new_from_square = (from_row, from_col - 1)
  elif to_row > from_row and to_col > from_col:
      new_from_square = (from_row + 1, from_col + 1)
  elif to_row > from_row and to_col < from_col:
      new_from_square = (from_row + 1, from_col - 1)
  elif to_row < from_row and to_col > from_col:
      new_from_square = (from_row - 1, from_col + 1)
  elif to_row < from_row and to_col < from_col:
      new_from_square = (from_row - 1, from_col - 1)

  if board[new_from_square[0]][new_from_square[1]] != ".":
      return False
  else:
      return IsClearPath(new_from_square, to_square, board)

# makes a hypothetical move (from-square and to-square)
# returns True if it puts current player into check
def DoesMovePutPlayerInCheck(curPlayer, from_square, to_square, board):
    # given the move (from-square and to-square), find the 'from-piece' and 'to-piece'
    # make the move temporarily by changing the 'board'
    # Call the IsInCheck() function to see if the 'player' is in check - save the returned value
    # Undo the temporary move
    # return the value saved - True if it puts current player into check, False otherwise


    from_piece = board[from_square[0]][from_square[1]]
    to_piece = board[to_square[0]][to_square[1]]

    # Make the move temporarily by changing the 'board'
    board[to_square[0]][to_square[1]] = from_piece
    board[from_square[0]][from_square[1]] = '.'

    # Call the IsInCheck() function to see if the 'player' is in check - save the returned value
    is_in_check = IsInCheck(curPlayer , board)

    # Undo the temporary move
    board[from_square[0]][from_square[1]] = from_piece
    board[to_square[0]][to_square[1]] = to_piece

    # Return the value saved - True if it puts the current player into check, False otherwise
    return is_in_check

"""#Artificial Intelligence

In this section, you will write code for the Artificial Intelligence (AI) that will play a game of chess. You will write 2 types of AI:

1.   **RandomAI** - This part will contain code for moving a chess piece randomly.
2.   **MinMaxAI** - This part will contain code for moving a chess piece using the MinMax strategy discussed in the lecture.

##RandomAI

(10 points)

Complete the function below that will perform a random move for the given player. The function will return the move (from-piece and to-piece). You will most likely not need to write any other function, but you can, if needed.
"""

def GetRandomMove(player, board):
    # pick a random piece and a random legal move for that piece
  pieces_with_legal_moves = GetPiecesWithLegalMoves(player, board)

    # Pick a random piece from the pieces_with_legal_moves list
    #print("pieces_with_legal_moves from GetRandomMove.\n",pieces_with_legal_moves)

  # Pick a random piece
  from_piece = random.choice(pieces_with_legal_moves)

  # Get the list of legal moves for the random piece
  legal_moves = GetListOfLegalMoves(player, from_piece, board)

  # Pick a random legal move
  to_piece = random.choice(legal_moves)

  # Return the random move
  return from_piece, to_piece

"""##MinMaxAI

(50 points)

Complete the functions below that will perform a move for the given player using the MinMax AI strategy. One function will evaluate the board if a move is performed - give score for each of piece and calculate the score for the entire chess board. In the second function you will write actual code for the MinMax strategy and return the move (from-piece and to-piece). To get the allocated points, searching should be **2-ply (one Max and one Min)**. You will most likely not need to write any other function, but you can, if needed.

## Extra Credit

*   **(5 points)** Modify the above MinMax strategy to be **4-ply (one Max, one Min, one Max, one Min)**.
*   **(10 points)** Perform **alpha-beta pruning** for the MinMax strategy.
"""

def evl(board):
    # this function will calculate the score on the board, if a move is performed
    # give score for each of piece and calculate the score for the chess board
  scores = {
        'p': 1, 'P': -1,
        'r': 5, 'R': -5,
        't': 3, 'T': -3,
        'b': 3, 'B': -3,
        'q': 9, 'Q': -9,
        'k': 10000, 'K': -10000
    }

  total_score = 0

  for row in board:
      for piece in row:
          if piece in scores:
              total_score += scores[piece]

  return total_score

def GetMinMaxMove(player, board):
    # return the best move for the current player using the MinMax strategy
    # to get the allocated points, searching should be 2-ply (one Max and one Min)

    # Following is the setup for a 2-ply game

    # pieces = GetPiecesWithLegalMoves(curPlayer)
    # for each piece in pieces
        # moves = GetListOfLegalMoves(curPlayer, piece)
        # for move in moves
            # perform the move temporarily
            # enemyPieces = GetPiecesWithLegalMoves(enemyPlayer)
            # for enemyPiece in penemyPiecesieces
                # enemyMoves = GetListOfLegalMoves(enemyPlayer, enemyPiece)
                # for enemyMove in enemyMoves
                    # perform the enemyMove temporarily
                    # res = evl(curPlayer)
                    # update the bestEnemyMove -- this is the MIN player trying to minimize from the 'res' evaluation values
                    # undo the enemyMove
            # update the bestMove -- this is the MAX player trying to maximize from the 'bestEnemyMove' evaluation values
            # undo the move
    # if bestMove found without any doubt, pick that
    # if bestMove not found, pick randomly

    # OPTIONAL -- sometimes automated chess keeps on performing the moves again and again
    # e.g., move king left one square and then move king back - repeat
    # For this you will need to remember the previous move and see if the current best move is not the same and opposite as the previous move
    # If so, pick the second best move instead of the best move


  # Define the player and enemyPlayer based on the current player
    enemyPlayer = 'white' if player == 'black' else 'black'


    pieces = GetPiecesWithLegalMoves(player, board)


    bestMove = None

    # Initialize bestMoveScore for MAX player (to maximize)
    bestMoveScore = -10000


    for piece in pieces:
        # Get the list of legal moves for the current piece
        moves = GetListOfLegalMoves(player, piece, board)

        for move in moves:
            # Perform the move temporarily
            from_square = piece
            to_square = move
            temp_from_piece = board[from_square[0]][from_square[1]]
            temp_to_piece = board[to_square[0]][to_square[1]]

            board[to_square[0]][to_square[1]] = temp_from_piece
            board[from_square[0]][from_square[1]] = '.'

            # Get all pieces with legal moves for the enemy player
            enemyPieces = GetPiecesWithLegalMoves(enemyPlayer, board)

            # Initialize bestEnemyMoveScore for MIN player (to minimize)
            bestEnemyMoveScore = 10000


            for enemyPiece in enemyPieces:
                # Get the list of legal moves for the enemy piece
                enemyMoves = GetListOfLegalMoves(enemyPlayer, enemyPiece, board)

                # Loop through each move for the enemy piece
                for enemyMove in enemyMoves:
                    # Perform the enemy move temporarily
                    enemy_from_square = enemyPiece
                    enemy_to_square = enemyMove
                    temp_enemy_from_piece = board[enemy_from_square[0]][enemy_from_square[1]]
                    temp_enemy_to_piece = board[enemy_to_square[0]][enemy_to_square[1]]

                    board[enemy_to_square[0]][enemy_to_square[1]] = temp_enemy_from_piece
                    board[enemy_from_square[0]][enemy_from_square[1]] = '.'

                    # Evaluate the board for the current player
                    evaluation = evl(board)

                    # update the bestEnemyMove -- this is the MIN player trying to minimize from the 'res' evaluation values
                    bestEnemyMoveScore = min(bestEnemyMoveScore, evaluation)

                    # Undo the enemy move
                    board[enemy_from_square[0]][enemy_from_square[1]] = temp_enemy_from_piece
                    board[enemy_to_square[0]][enemy_to_square[1]] = temp_enemy_to_piece

            # # update the bestMove -- this is the MAX player trying to maximize from the 'bestEnemyMove' evaluation values
            if bestEnemyMoveScore > bestMoveScore:
                bestMoveScore = bestEnemyMoveScore
                bestMove = (piece, move)

            # Undo the move
            board[from_square[0]][from_square[1]] = temp_from_piece
            board[to_square[0]][to_square[1]] = temp_to_piece

    # If bestMove is found without any doubt, return it
    if bestMove is not None:
        return bestMove


    # if bestMove not found, pick randomly
    return GetRandomMove(player, board)

"""#Game Setup & Main Loop

(05 points)

Write code below to have a game-play between two AIs - Random vs MinMax. For each iteration, draw the board before and after a turn.
"""

# initialize and setup the board
board = ChessBoardSetup()
# player assignment and counter initializations
players = ['white', 'black']
current_player = players[0]
turns = 0
N = 60

# main game loop - while a player is not in checkmate or stalemate (<N turns)
# below is the rough looping strategy
while not IsCheckmate(current_player, board) and turns < N:
    clear_output()
    DrawBoard(board)

    # Take turns and move the pieces
    print("\nPlayer", current_player, "turn")
    time.sleep(0.5)

    if current_player == 'white':
        # Perform move for WHITE player using MinMax strategy
        from_square, to_square = GetMinMaxMove(current_player, board)
    else:
        # Perform move for BLACK player randomly
        from_square, to_square = GetRandomMove(current_player, board)

    if from_square is None or to_square is None:
        print("No valid move available. Stalemate!")
        break
    # Move the piece on the board
    board = MovePiece(board, from_square, to_square)

    DrawBoard(board)
    time.sleep(0.5)
    # Switch to the next player
    current_player = players[(players.index(current_player) + 1) % 2]
    turns += 1

# check and print - Stalemate or Checkmate
if IsCheckmate(current_player, board):
    print("Checkmate! Player", current_player, "wins!")
else:
    print("Stalemate! The game ends in a draw.")

"""#Submission Instructions

1.   Complete all tasks above - **File MUST contain the output for ALL cells**
2.   Export this notebook as .ipynb
      (File > Download as ipynb)
3.   Upload the .ipynb file on Blackboard

##Rubric

*   (10 points) Chess Board Setup
*   (50 points) Chess Rules Setup
*   (10 points) Random AI
*   (50 points) MinMax AI (2-ply)
*   (05 points) Game Main Loop - Random vs MinMax
*   (15 points) Extra Credit - 4-ply MinMax + alpha-beta pruning
"""